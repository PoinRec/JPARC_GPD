//2021-09-12, uploaded by yokkaich
//2020-09-16, uploaded by yokkaich
//2020-08-30, uploaded by yokkaich
//2016-05-02, uploaded by nakai
//2016-04-01, uploaded by nakai
//2015-12-12, uploaded by nakai
//2015-11-02, uploaded by yokkaich
//2015-11-02, uploaded by komatsu
//2015-03-28, uploaded by yokkaich
//2015-03-27, uploaded by yokkaich
//2015-01-28, uploaded by komatsu
//2015-01-05, uploaded by yokkaich
//2015-01-05, uploaded by yokkaich
//2014-08-27, uploaded by kawama
//2014-05-07, uploaded by kawama
//2014-04-30, uploaded by kawama
//2014-04-24, uploaded by kawama
//2013-11-14, uploaded by kawama
//2013-05-13, modified by kawama
//2013-05-13, modified by kawama
/*
//E16ANA_MagneticFieldMap.hh 150104 by S. Yokkaichi
//    Last modified at <>
 from

  E16ANA_FMField.hh

  Field Manager Class
  Read Field Data generated by Tosca

*/


#ifndef E16ANA_MagneticFieldMap_HH

#define E16ANA_MagneticFieldMap_HH 1

#include <string>
#include <vector>
#include <CLHEP/Vector/ThreeVector.h>
#include <CLHEP/Vector/LorentzVector.h>
#include <cstdio>

//#include "E16ANA_ErrorMessage.hh"

class E16ANA_MagneticFieldMap
{
public:
  static E16ANA_MagneticFieldMap* GlobalPointer();
  static void SetGlobalPointer( E16ANA_MagneticFieldMap* p);

public:
  E16ANA_MagneticFieldMap(){}
  virtual ~E16ANA_MagneticFieldMap()  { }

private:
  E16ANA_MagneticFieldMap( const E16ANA_MagneticFieldMap & );
  E16ANA_MagneticFieldMap & operator = ( const E16ANA_MagneticFieldMap & );

public:
  enum{ ERROR = -9999};
  virtual bool GetFieldValue( const double point[3], double *Bfield, int bcflag ) const =0;// call by cm, get gauss

  virtual bool GetFieldValue_Tesla( const double point[3], double *Bfield, int bcflag ) const =0;// call by mm, get Tesla

  virtual int Initialize( void );
  virtual int Initialize_binary( const char* bindatafilename);
  virtual int Initialize_binary();
  virtual int Initialize_shift(CLHEP::Hep3Vector shiftV);

};

class E16ANA_MagneticFieldMap3D :public E16ANA_MagneticFieldMap
{
private:
  std::string FieldMapFileName;
public:
  E16ANA_MagneticFieldMap3D( const std::string & filename )
    : FieldMapFileName(filename), Nx(0), Ny(0), Nz(0)
  {SetSmearParameters();}
  ~E16ANA_MagneticFieldMap3D()  { cleanupMap(); }
  E16ANA_MagneticFieldMap3D(){SetSmearParameters();};
private:
  E16ANA_MagneticFieldMap3D( const E16ANA_MagneticFieldMap3D & );
  E16ANA_MagneticFieldMap3D & operator = ( const E16ANA_MagneticFieldMap3D & );

public:
  int Initialize( void );//read text map
  int Initialize_binary( const char* bindatafilename);
  int Initialize_binary(){
    return Initialize_binary( FieldMapFileName.c_str() );
  };

  bool GetFieldValue( const double point[3], double *Bfield, int bcflag ) const; 
  bool GetFieldValue_Tesla( const double point[3], double *Bfield, int bcflag ) const; 

  //  void SetFieldMap( const std::string & filename )
  //   { FieldMapFileName = filename; }

//-------------for map study tools------------
  int MapConvert( char* writefilename);// text map ->bininary map

  int Initialize_shift(CLHEP::Hep3Vector shiftV);
  int WriteBinaryFile(const std::string &file_name);

  int RandomSmear(int seed);
  int AddShift();

  void SetSmearParameters(double smear);

private:
  struct FD {//field data
    float x, y, z;
  }; 
  typedef std::vector < std::vector < std::vector < FD > > > FDContainer;
  // FDContainer is 3-dimensional (x-y-z) array of "FD"

  FDContainer B;
  FDContainer B_x;
  FDContainer B_y;
  FDContainer B_z;
  FDContainer B_xy;
  FDContainer B_yz;
  FDContainer B_zx;
  // Initial point
  double X0, Y0, Z0;
  // cell size
  double dX, dY, dZ;
  // Number of cell
  int Nx, Ny, Nz;

  double smear_bx, smear_by, smear_bz; // percent
  enum{n_regions = 6};
  int GetRegionId(double x, double y, double z){
     if(x < +50.0){
        if(y < -25.0){
           return 0;
        }else if(y < +25.0){
           return 1;
        }else{
           return 2;
        }
     }else{
        if(y < -25.0){
           return 3;
        }else if(y < +25.0){
           return 4;
        }else{
           return 5;
        }
     }
  };
  double shift_bx[n_regions]; // percent
  double shift_by[n_regions]; // percent
  double shift_bz[n_regions]; // percent
  void SetSmearParameters();

  void cleanupMap( void );

   void bcuint(float y[], float y1[], float y2[], float y12[],
      float x1l, float x1u, float x2l, float x2u, float x1, float x2,
      float *ansy, float *ansy1, float *ansy2) const;
   void bcuint2(float y[], float y1[], float y2[], float y12[],
      float x1l, float x1u, float x2l, float x2u, float x,
      float *ansy1, float *ansy2) const;
   void bcucof(float y[], float y1[], float y2[], float y12[],
      float d1, float d2, float c[4][4]) const;
   void polint(float xa[], float ya[], int n, float x, 
      float *y, float *dy) const;
};



class E16ANA_MagneticFieldConst : public E16ANA_MagneticFieldMap
{
private:
  double B[3];//Tesla
  int axis;// 0,1,2 = x, y, z
public:
  E16ANA_MagneticFieldConst(double tesla, int iaxis):axis(iaxis){
    B[0]=0;B[1]=0;B[2]=0;
    if( axis<0 || 2<axis){
      printf("axis error:should be 0,1, or 2, i.e. x,y,z\n");
    }
    else{
      B[axis]=tesla;
    }
    
  }

  ~E16ANA_MagneticFieldConst() {}

public:

  bool GetFieldValue( const double point[3], double *Bfield, int bcflag ) 
    const {
    Bfield[0]=B[0]*10000;  Bfield[1]=B[1]*10000;  Bfield[2]=B[2]*10000;
    return true;
  }
  virtual bool GetFieldValue_Tesla( const double point[3], double *Bfield, int bcflag ) 
    const {
    Bfield[0]=B[0];  Bfield[1]=B[1];  Bfield[2]=B[2];
    return true;
  }

private:

};


#endif //E16ANA_MagneticFieldMap_HH



